
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-api/handler/artifacthub.go (0.0%)</option>
				
				<option value="file1">go-api/handler/charts.go (86.3%)</option>
				
				<option value="file2">go-api/handler/common.go (23.3%)</option>
				
				<option value="file3">go-api/handler/healthcheck.go (0.0%)</option>
				
				<option value="file4">go-api/handler/releases.go (0.0%)</option>
				
				<option value="file5">go-api/handler/repositories.go (65.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handler

import (
        "encoding/json"
        "fmt"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "go-api/common"
        "go-api/config"
        "io"
        "net/http"
        "strconv"
        "strings"
)

type artifactRepositoryElement struct {
        Id                string `json:"repository_id"`
        Name              string `json:"name"`
        URL               string `json:"url"`
        Kind              int    `json:"kind"`
        VerifiedPublisher bool   `json:"verified_publisher"`
        Official          bool   `json:"official"`
        Disabled          bool   `json:"disabled"`
}

type artifactPackageElement struct {
        Id          string `json:"package_id"`
        Name        string `json:"name"`
        Version     string `json:"version"`
        AppVersion  string `json:"app_version"`
        Description string `json:"description"`
        LogoImageId string `json:"logo_image_id"`
        Icon        string `json:"icon"`
        Deprecated  bool   `json:"deprecated"`
}

type artifactPackageList struct {
        Packages []artifactPackageElement `json:"packages"`
}

type artifactPackage struct {
        Id                string        `json:"package_id"`
        Name              string        `json:"name"`
        Version           string        `json:"version"`
        AppVersion        string        `json:"app_version"`
        Description       string        `json:"description"`
        LogoImageId       string        `json:"logo_image_id"`
        Icon              string        `json:"icon"`
        Deprecated        bool          `json:"deprecated"`
        License           string        `json:"license"`
        HomeUrl           string        `json:"home_url"`
        AvailableVersions []interface{} `json:"available_versions"`
        Links             []interface{} `json:"links"`
        ContentUrl        string        `json:"content_url"`
        Repository        interface{}   `json:"repository"`
}

type respData struct {
        TotalCount int
        Data       []byte
}

// SearchRepoHub
// @Summary Search Repo ArtifactHub
// @Tags ArtifactHub
// @Accept json
// @Produce json
// @Router /api/hub/repositories [Get]
func SearchRepoHub(c *fiber.Ctx) error <span class="cov0" title="0">{
        lse, err := ListSearchCheck(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">name := c.Query("name")
        url := c.Query("url")
        params := fmt.Sprintf("&amp;limit=0&amp;name=%v&amp;url=%v", name, url)
        reqUrl := fmt.Sprintf("%v%v", config.Env.ArtifactHubUrl, config.Env.ArtifactHubRepoSearch) + params
        respData, err := getRequestData(reqUrl, true)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">var repoElements []artifactRepositoryElement
        if err := json.Unmarshal(respData.Data, &amp;repoElements); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">repos := make([]interface{}, 0, len(repoElements))
        for _, re := range repoElements </span><span class="cov0" title="0">{
                if !re.Disabled &amp;&amp; re.VerifiedPublisher </span><span class="cov0" title="0">{
                        repos = append(repos, re)
                }</span>
        }

        <span class="cov0" title="0">itemCount, resultData := ResourceListProcessing(repos, lse)
        return common.ListRespOK(c, itemCount, resultData)</span>
}

// SearchPackageHub
// @Summary Search Package ArtifactHub
// @Tags ArtifactHub
// @Accept json
// @Produce json
// @Router /api/hub/packages [Get]
func SearchPackageHub(c *fiber.Ctx) error <span class="cov0" title="0">{
        lse, err := ListSearchCheck(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">if lse.Limit &lt; 1 || lse.Limit &gt; 60 </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.HUB_PACKAGE_LIMIT_ILLEGAL_ARGUMENT))
        }</span>
        <span class="cov0" title="0">repo := c.Query("repo")
        query := c.Query("query")

        params := fmt.Sprintf("&amp;offset=%v&amp;limit=%v&amp;ts_query_web=%v", lse.Offset*lse.Limit, lse.Limit, query)
        if len(repo) &gt; 0 </span><span class="cov0" title="0">{
                params += "&amp;repo=" + repo
        }</span>

        <span class="cov0" title="0">reqUrl := fmt.Sprintf("%v%v", config.Env.ArtifactHubUrl, config.Env.ArtifactHubPackageSearch) + params
        respData, err := getRequestData(reqUrl, true)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">var artifactPackageList artifactPackageList
        if err := json.Unmarshal(respData.Data, &amp;artifactPackageList); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">remainingItemCount := respData.TotalCount - ((lse.Offset + 1) * lse.Limit)
        if remainingItemCount &lt; 0 </span><span class="cov0" title="0">{
                remainingItemCount = 0
        }</span>
        <span class="cov0" title="0">listCount := common.ListCount{
                AllItemCount:       respData.TotalCount,
                RemainingItemCount: remainingItemCount,
        }

        packages := make([]interface{}, 0, len(artifactPackageList.Packages))
        for _, re := range artifactPackageList.Packages </span><span class="cov0" title="0">{
                if len(re.LogoImageId) &gt; 0 </span><span class="cov0" title="0">{
                        re.Icon = config.Env.ArtifactHubPackageLogoUrl + re.LogoImageId
                }</span>
                <span class="cov0" title="0">packages = append(packages, re)</span>
        }

        <span class="cov0" title="0">return common.ListRespOK(c, listCount, packages)</span>
}

// GetHelmPackageInfo
// @Summary Get Helm Package Chart Details
// @Tags ArtifactHub
// @Accept json
// @Produce json
// @Router /api/hub/packages/:repositories/:packages [Get]
func GetHelmPackageInfo(c *fiber.Ctx) error <span class="cov0" title="0">{
        repoName := c.Params("repositories")
        packageName := c.Params("packages")

        packageDetailUrl := strings.ReplaceAll(config.Env.ArtifactHubPackageDetail, "{repoName}", repoName)
        packageDetailUrl = strings.ReplaceAll(packageDetailUrl, "{packageName}", packageName)

        reqUrl := fmt.Sprintf("%v%v", config.Env.ArtifactHubUrl, packageDetailUrl)
        respData, err := getRequestData(reqUrl, false)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">var artifactPackage artifactPackage
        if err := json.Unmarshal(respData.Data, &amp;artifactPackage); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">if len(artifactPackage.LogoImageId) &gt; 0 </span><span class="cov0" title="0">{
                artifactPackage.Icon = config.Env.ArtifactHubPackageLogoUrl + artifactPackage.LogoImageId
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, artifactPackage)</span>
}

// GetHelmPackageValues
// @Summary Get Helm Package Chart Values
// @Tags ArtifactHub
// @Accept json
// @Produce json
// @Router /api/hub/packages/:packageID/:version/values [Get]
func GetHelmPackageValues(c *fiber.Ctx) error <span class="cov0" title="0">{
        packageID := c.Params("packageID")
        version := c.Params("version")

        packageValueUrl := strings.ReplaceAll(config.Env.ArtifactHubPackageValues, "{packageID}", packageID)
        packageValueUrl = strings.ReplaceAll(packageValueUrl, "{version}", version)

        reqUrl := fmt.Sprintf("%v%v", config.Env.ArtifactHubUrl, packageValueUrl)
        respData, err := getRequestData(reqUrl, false)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, string(respData.Data))</span>
}

func getRequestData(url string, isList bool) (respData, error) <span class="cov0" title="0">{
        log.Infof("SEND :: REQUEST-URL: %s", url)
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return respData{}, err
        }</span>

        // resp.Body.close()
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        err := resp.Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err)
                        }</span>
                }
        }()

        // if 404 notfound
        <span class="cov0" title="0">if resp.StatusCode == fiber.StatusNotFound </span><span class="cov0" title="0">{
                return respData{}, fmt.Errorf(common.NOT_FOUND)
        }</span>

        // read body
        <span class="cov0" title="0">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return respData{}, err
        }</span>

        <span class="cov0" title="0">if !isList </span><span class="cov0" title="0">{
                return respData{0, data}, nil
        }</span>

        //Pagination-Total-Count
        <span class="cov0" title="0">totalCount, err := strconv.Atoi(resp.Header.Get("Pagination-Total-Count"))
        if err != nil </span><span class="cov0" title="0">{
                return respData{}, err
        }</span>

        <span class="cov0" title="0">return respData{totalCount, data}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "fmt"
        "github.com/Masterminds/semver/v3"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "go-api/common"
        "helm.sh/helm/v3/cmd/helm/search"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/helmpath"
        "helm.sh/helm/v3/pkg/repo"
        "path/filepath"
)

// searchMaxScore suggests that any score higher than this is not considered a match.
const searchMaxScore = 25

var readmeFileNames = []string{"readme.md", "readme.txt", "readme"}

type file struct {
        Name string `json:"name"`
        Data string `json:"data"`
}

type repoChartElement struct {
        Name        string `json:"name"`
        Version     string `json:"version"`
        AppVersion  string `json:"app_version"`
        Home        string `json:"home"`
        Description string `json:"description"`
        Icon        string `json:"icon"`
        RepoName    string `json:"repoName"`
        Deprecated  bool   `json:"deprecated"`
}

type repoChartList []repoChartElement

// GetChartVersions
// @Summary Get Chart Versions
// @Tags Charts
// @Accept json
// @Produce json
// @Router /api/charts/:charts/versions [Get]
func GetChartVersions(c *fiber.Ctx) error <span class="cov8" title="1">{
        charts := c.Params("charts")    // search keyword
        repoName := c.Query("repo", "") // repo name
        version := c.Query("version")
        // default stable
        if version == "" </span><span class="cov8" title="1">{
                version = "&gt;0.0.0"
        }</span>

        <span class="cov8" title="1">log.Infof("GetChartVersions:: repoName: %v, charts: %v", repoName, charts)
        var index *search.Index
        var err error
        var keyword string

        if len(repoName) &lt; 1 </span><span class="cov0" title="0">{
                // search in all repos
                //        index, err = buildSearchIndexAll()
                keyword = fmt.Sprintf("/%s\v", charts)
        }</span> else<span class="cov8" title="1"> {
                index, err = buildSearchIndex(repoName)
                keyword = fmt.Sprintf("\v%s/%s\v", repoName, charts)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">var res []*search.Result
        res, err = index.Search(keyword, searchMaxScore, true)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">search.SortScore(res)
        data, err := applyConstraint(version, true, res)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">if len(data) &lt; 1 </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.CHART_NOT_FOUND))
        }</span>

        <span class="cov8" title="1">chartList := make(repoChartList, 0, len(data))
        for _, v := range data </span><span class="cov8" title="1">{
                chartList = append(chartList, repoChartElement{
                        Name:       v.Name,
                        Version:    v.Chart.Version,
                        AppVersion: v.Chart.AppVersion,
                        Home:       v.Chart.Home,
                        Deprecated: v.Chart.Deprecated,
                })
        }</span>

        <span class="cov8" title="1">return common.RespOK(c, chartList)</span>
}

// GetChartInfo
// @Summary Get Chart Info
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories/:repositories/charts/:charts/info [Get]
func GetChartInfo(c *fiber.Ctx) error <span class="cov8" title="1">{
        repoName := c.Params("repositories")
        charts := c.Params("charts") // search keyword
        version := c.Query("version")
        info := c.Query("info") // all, readme, values, chart

        if info == "" </span><span class="cov8" title="1">{
                info = string(action.ShowAll)
        }</span>

        <span class="cov8" title="1">actionConfig := new(action.Configuration)
        client := action.NewShowWithConfig(action.ShowAll, actionConfig)
        client.Version = version
        if info == string(action.ShowChart) </span><span class="cov8" title="1">{
                client.OutputFormat = action.ShowChart
        }</span> else<span class="cov8" title="1"> if info == string(action.ShowReadme) </span><span class="cov8" title="1">{
                client.OutputFormat = action.ShowReadme
        }</span> else<span class="cov8" title="1"> if info == string(action.ShowValues) </span><span class="cov8" title="1">{
                client.OutputFormat = action.ShowValues
        }</span> else<span class="cov8" title="1"> if info == string(action.ShowAll) </span><span class="cov8" title="1">{
                client.OutputFormat = action.ShowAll
        }</span> else<span class="cov0" title="0"> {
                return common.RespErr(c, fmt.Errorf("chart info only support readme/values/chart"))
        }</span>

        <span class="cov8" title="1">aimChart := fmt.Sprintf("%s/%s", repoName, charts)
        cp, err := client.ChartPathOptions.LocateChart(aimChart, settings)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">chrt, err := loader.Load(cp)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">if client.OutputFormat == action.ShowChart </span><span class="cov8" title="1">{
                return common.RespOK(c, chrt.Metadata)
        }</span>
        <span class="cov8" title="1">if client.OutputFormat == action.ShowValues </span><span class="cov8" title="1">{
                var values string
                for _, v := range chrt.Raw </span><span class="cov8" title="1">{
                        if v.Name == chartutil.ValuesfileName </span><span class="cov8" title="1">{
                                values = string(v.Data)
                                break</span>
                        }
                }
                <span class="cov8" title="1">return common.RespOK(c, values)</span>
        }
        <span class="cov8" title="1">if client.OutputFormat == action.ShowReadme </span><span class="cov8" title="1">{
                return common.RespOK(c, chrt.Files)
        }</span>
        <span class="cov8" title="1">if client.OutputFormat == action.ShowAll </span><span class="cov8" title="1">{
                values := make([]*file, 0, len(chrt.Raw))
                for _, v := range chrt.Raw </span><span class="cov8" title="1">{
                        values = append(values, &amp;file{
                                Name: v.Name,
                                Data: string(v.Data),
                        })
                }</span>

                <span class="cov8" title="1">return common.RespOK(c, values)</span>
        }
        <span class="cov0" title="0">return common.RespOK(c, nil)</span>
}

func buildSearchIndex(repoName string) (*search.Index, error) <span class="cov8" title="1">{
        index := search.NewIndex()
        path := filepath.Join(settings.RepositoryCache, helmpath.CacheIndexFile(repoName))
        indexFile, err := repo.LoadIndexFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.REPO_CORRUPT_MISSING)
        }</span>

        <span class="cov8" title="1">index.AddRepo(repoName, indexFile, true)
        return index, nil</span>
}

func applyConstraint(version string, versions bool, res []*search.Result) ([]*search.Result, error) <span class="cov8" title="1">{
        if len(version) == 0 </span><span class="cov0" title="0">{
                return res, nil
        }</span>

        <span class="cov8" title="1">constraint, err := semver.NewConstraint(version)
        if err != nil </span><span class="cov0" title="0">{
                return res, fmt.Errorf(common.CHART_VERSION_INVALID)
        }</span>

        <span class="cov8" title="1">data := res[:0]
        foundNames := map[string]bool{}
        for _, r := range res </span><span class="cov8" title="1">{
                // if not returning all versions and already have found a result,
                // you're done!
                if !versions &amp;&amp; foundNames[r.Name] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">v, err := semver.NewVersion(r.Chart.Version)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if constraint.Check(v) </span><span class="cov8" title="1">{
                        data = append(data, r)
                        foundNames[r.Name] = true
                }</span>
        }

        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "encoding/json"
        "fmt"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/google/uuid"
        "go-api/common"
        "go-api/config"
        "helm.sh/helm/v3/pkg/cli"
        "io"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        v1 "k8s.io/apimachinery/pkg/apis/testapigroup/v1"
        "k8s.io/apimachinery/pkg/util/yaml"
        "os"
        "path/filepath"
        "reflect"
        sigyaml "sigs.k8s.io/yaml"
        "strconv"
        "strings"
)

var (
        settings = cli.New()
)

type ListSearchElement struct {
        Offset     int
        Limit      int
        SearchName string
}

func Settings() <span class="cov0" title="0">{
        settings.RepositoryConfig = config.Env.HelmRepoConfig
        settings.RepositoryCache = config.Env.HelmRepoCache
}</span>

func GetResources(out string) []*v1.Carp <span class="cov0" title="0">{
        res, err := ParseManifests(out)
        if err != nil </span><span class="cov0" title="0">{
                res = append(res, &amp;v1.Carp{
                        TypeMeta: metav1.TypeMeta{Kind: "ManifestParseError"},
                        ObjectMeta: metav1.ObjectMeta{
                                Name: err.Error(),
                        },
                        Spec: v1.CarpSpec{},
                        Status: v1.CarpStatus{
                                Phase:   "BrokenManifest",
                                Message: err.Error(),
                        },
                })
                //_ = c.AbortWithError(http.StatusInternalServerError, err)
                //return
        }</span>
        <span class="cov0" title="0">return res</span>
}

func ParseManifests(out string) ([]*v1.Carp, error) <span class="cov0" title="0">{
        dec := yaml.NewYAMLOrJSONDecoder(strings.NewReader(out), 4096)
        res := make([]*v1.Carp, 0)
        var tmp interface{}
        for </span><span class="cov0" title="0">{
                err := dec.Decode(&amp;tmp)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>

                <span class="cov0" title="0">jsoned, err := json.Marshal(tmp)
                if err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>

                <span class="cov0" title="0">var doc v1.Carp
                err = json.Unmarshal(jsoned, &amp;doc)
                if err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>

                <span class="cov0" title="0">if doc.Kind == "" </span><span class="cov0" title="0">{
                        log.Warnf("Manifest piece is not k8s resource: %s", jsoned)
                        continue</span>
                }

                <span class="cov0" title="0">res = append(res, &amp;doc)</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func ConvertYAML(results map[string]interface{}) string <span class="cov0" title="0">{
        obj, err := sigyaml.Marshal(results)
        if err != nil </span><span class="cov0" title="0">{
                return common.EMPTY_STR
        }</span>
        <span class="cov0" title="0">return string(obj)</span>
}

func FileExists(filename string) bool <span class="cov0" title="0">{
        info, err := os.Stat(filename)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return !info.IsDir()</span>
}

func RemoveFile(filename string) error <span class="cov8" title="1">{
        if len(filename) &gt; 0 </span><span class="cov0" title="0">{
                log.Infof("Delete file :: %s", filename)
                err := os.Remove(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

func ListSearchCheck(c *fiber.Ctx) (*ListSearchElement, error) <span class="cov8" title="1">{
        offset, err := strconv.Atoi(c.Query("offset", "0"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.OFFSET_VAL_INVALID)
        }</span>
        <span class="cov8" title="1">limit, err := strconv.Atoi(c.Query("limit", "0"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.LIMIT_VAL_INVALID)
        }</span>
        <span class="cov8" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.OFFSET_ILLEGAL_ARGUMENT)
        }</span>
        <span class="cov8" title="1">if limit &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.LIMIT_ILLEGAL_ARGUMENT)
        }</span>
        <span class="cov8" title="1">if offset &gt; 0 &amp;&amp; limit == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.OFFSET_REQUIRES_LIMIT_ILLEGAL_ARGUMENT)
        }</span>

        <span class="cov8" title="1">lse := ListSearchElement{
                Offset:     offset,
                Limit:      limit,
                SearchName: strings.TrimSpace(c.Query("searchName", "")),
        }

        return &amp;lse, nil</span>
}

func ResourceListProcessing(list []interface{}, lse *ListSearchElement) (common.ListCount, []interface{}) <span class="cov8" title="1">{
        // 1. search keyword
        if lse.SearchName != "" </span><span class="cov0" title="0">{
                list = searchResourceName(list, lse.SearchName)
        }</span>

        // 2. paging (offset &amp; limit)
        <span class="cov8" title="1">allItemCount := len(list)
        if allItemCount &lt; 1 </span><span class="cov0" title="0">{
                return common.ListCount{}, make([]interface{}, 0)
        }</span>

        <span class="cov8" title="1">remainingItemCount := allItemCount - ((lse.Offset + 1) * lse.Limit)
        start := lse.Offset * lse.Limit

        if lse.Limit == 0 || remainingItemCount &lt; 0 </span><span class="cov8" title="1">{
                remainingItemCount = 0
        }</span>

        <span class="cov8" title="1">listCount := common.ListCount{
                AllItemCount:       allItemCount,
                RemainingItemCount: remainingItemCount,
        }

        if lse.Limit == 0 </span><span class="cov8" title="1">{
                return listCount, list
        }</span>
        <span class="cov0" title="0">if start &gt; allItemCount </span><span class="cov0" title="0">{
                return listCount, make([]interface{}, 0)
        }</span>
        <span class="cov0" title="0">if (start + lse.Limit) &gt; allItemCount </span><span class="cov0" title="0">{
                return listCount, list[start:]
        }</span>

        <span class="cov0" title="0">return listCount, list[start : start+lse.Limit]</span>
}

func searchResourceName(list []interface{}, searchName string) []interface{} <span class="cov0" title="0">{
        var searchList []interface{}
        for _, re := range list </span><span class="cov0" title="0">{
                name := reflect.ValueOf(re).FieldByName("Name").String()
                if strings.Contains(name, searchName) </span><span class="cov0" title="0">{
                        searchList = append(searchList, re)
                }</span>
        }
        <span class="cov0" title="0">return searchList</span>
}

func RemoveGlob(path string) (err error) <span class="cov0" title="0">{
        contents, err := filepath.Glob(path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, item := range contents </span><span class="cov0" title="0">{
                err = os.RemoveAll(item)
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("Error removing files: %+v", err)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func generatingId() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

func procReplaceEmpty(value string) string <span class="cov0" title="0">{
        if len(value) &lt; 1 </span><span class="cov0" title="0">{
                return common.EMPTY_STR
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import "github.com/gofiber/fiber/v2"

type HealthStatus struct {
        Status string   `json:"status"`
        Groups []string `json:"groups,omitempty"`
}

const StatusUp = "UP"

func Health(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(HealthStatus{
                Status: StatusUp,
                Groups: []string{"liveness", "readiness"},
        })
}</span>
func HealthCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(HealthStatus{
                Status: StatusUp,
        })
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "bytes"
        "errors"
        "fmt"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "go-api/common"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/downloader"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/release"
        "helm.sh/helm/v3/pkg/releaseutil"
        "helm.sh/helm/v3/pkg/storage/driver"
        "k8s.io/kubectl/pkg/cmd/get"
        "sigs.k8s.io/yaml"
        "strconv"
        "time"
)

var defaultTimeout = "5m0s"

type releaseElement struct {
        Name         string      `json:"name"`
        Namespace    string      `json:"namespace"`
        Repo         string      `json:"repo"`
        Revision     string      `json:"revision"`
        Updated      string      `json:"updated"`
        Status       string      `json:"status"`
        Chart        string      `json:"chart"`
        ChartVersion string      `json:"chart_version"`
        AppVersion   string      `json:"app_version"`
        Home         string      `json:"home"`
        Icon         string      `json:"icon"`
        Notes        string      `json:"notes"`
        Values       string      `json:"values"`
        Resources    interface{} `json:"resources"`
        Manifest     string      `json:"manifest"`
}

type releaseInfo struct {
        Revision    int    `json:"revision"`
        Updated     string `json:"updated"`
        Status      string `json:"status"`
        Chart       string `json:"chart"`
        AppVersion  string `json:"app_version"`
        Description string `json:"description"`
        Manifest    string `json:"manifest"`
}
type releaseHistory []releaseInfo

// ListReleases
// @Summary List Releases
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases [Get]
func ListReleases(c *fiber.Ctx) error <span class="cov0" title="0">{
        lse, err := ListSearchCheck(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewList(actionConfig)
        client.All = true
        client.ByDate = true
        client.SortReverse = true
        results, err := client.Run()
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">elements := make([]interface{}, 0, len(results))
        for _, r := range results </span><span class="cov0" title="0">{
                elements = append(elements, constructReleaseElement(r, false))
        }</span>

        <span class="cov0" title="0">itemCount, resultData := ResourceListProcessing(elements, lse)
        return common.ListRespOK(c, itemCount, resultData)</span>
}

// GetReleaseInfo
// @Summary Get Releases Info
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release [Get]
func GetReleaseInfo(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("release")
        userDefined, err := strconv.ParseBool(c.Query("userDefined", "1"))
        log.Infof("GetReleaseInfo :: userDefined: %v", userDefined)

        actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewGet(actionConfig)
        results, err := client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, driver.ErrReleaseNotFound) </span><span class="cov0" title="0">{
                        return common.RespErr(c, fmt.Errorf(common.RELEASE_NOT_FOUND))
                }</span>
                <span class="cov0" title="0">return common.RespErr(c, err)</span>
        }

        <span class="cov0" title="0">releaseElement, err := constructReleaseInfoElement(results, userDefined)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, releaseElement)</span>
}

// InstallRelease
// @Summary Install Release
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release [Post]
func InstallRelease(c *fiber.Ctx) error <span class="cov0" title="0">{
        preview, err := strconv.ParseBool(c.Query("preview", "0"))
        userDefined, err := strconv.ParseBool(c.Query("userDefined", "1"))

        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        <span class="cov0" title="0">log.Infof("InstallRelease :: preview: %v, userDefined: %v", preview, userDefined)

        newRelease := new(releaseElement)
        if err := c.BodyParser(newRelease); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        <span class="cov0" title="0">newRelease.Name = c.Params("release")
        newRelease.Namespace = c.Params("namespace")

        if newRelease.Chart == "" </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.CHART_INFO_INVALID))
        }</span>

        <span class="cov0" title="0">rel, err := runInstall(c, newRelease, preview)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">releaseElement, err := constructReleaseInfoElement(rel, userDefined)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, releaseElement)</span>
}

// UpgradeRelease
// @Summary Upgrade Release
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release [Put]
func UpgradeRelease(c *fiber.Ctx) error <span class="cov0" title="0">{
        upgradeRelease := new(releaseElement)
        if err := c.BodyParser(upgradeRelease); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        <span class="cov0" title="0">upgradeRelease.Name = c.Params("release")
        upgradeRelease.Namespace = c.Params("namespace")
        if upgradeRelease.Chart == "" </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.CHART_INFO_INVALID))
        }</span>

        <span class="cov0" title="0">vals, err := mergeValues(upgradeRelease.Values)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewUpgrade(actionConfig)
        client.Namespace = upgradeRelease.Namespace
        client.Version = upgradeRelease.ChartVersion

        aimChart := fmt.Sprintf("%s/%s", upgradeRelease.Repo, upgradeRelease.Chart)
        cp, err := client.ChartPathOptions.LocateChart(aimChart, settings)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">if req := chartRequested.Metadata.Dependencies; req != nil </span><span class="cov0" title="0">{
                if err := action.CheckDependencies(chartRequested, req); err != nil </span><span class="cov0" title="0">{
                        return common.RespErr(c, err)
                }</span>
        }

        <span class="cov0" title="0">_, err = client.Run(upgradeRelease.Name, chartRequested, vals)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, nil)</span>
}

// RollbackRelease
// @Summary Rollback Release
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release/versions/:reversion [Put]
func RollbackRelease(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("release")
        reversionStr := c.Params("reversion")

        reversion, err := strconv.Atoi(reversionStr)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.REVERSION_NUMBER_INVALID))
        }</span>

        <span class="cov0" title="0">actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewRollback(actionConfig)
        client.Version = reversion

        err = client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, nil)</span>
}

// UninstallRelease
// @Summary Uninstall Release
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release [Delete]
func UninstallRelease(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("release")
        actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        <span class="cov0" title="0">err = runUninstall(actionConfig, name)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        <span class="cov0" title="0">return common.RespOK(c, nil)</span>
}

// GetReleaseHistories
// @Summary Get Release Histories
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release/histories [Get]
func GetReleaseHistories(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("release")
        actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewHistory(actionConfig)
        results, err := getHistory(client, name)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">return common.RespOK(c, results)</span>
}

// GetReleaseResources
// @Summary Get Release Resources
// @Tags Releases
// @Accept json
// @Produce json
// @Router /api/clusters/:clusterId/namespaces/:namespace/releases/:release/resources [Get]
func GetReleaseResources(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("release")
        actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">client := action.NewStatus(actionConfig)
        client.ShowResources = true
        client.ShowResourcesTable = true
        status, err := client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov0" title="0">buf := new(bytes.Buffer)
        if status.Info.Resources != nil &amp;&amp; len(status.Info.Resources) &gt; 0 </span><span class="cov0" title="0">{
                printFlags := get.NewHumanPrintFlags()
                typePrinter, _ := printFlags.ToPrinter("")
                printer := &amp;get.TablePrinter{Delegate: typePrinter}

                var keys []string
                for key := range status.Info.Resources </span><span class="cov0" title="0">{
                        keys = append(keys, key)
                }</span>

                <span class="cov0" title="0">for _, t := range keys </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(buf, "==&gt; %s\n", t)

                        vk := status.Info.Resources[t]
                        for _, resource := range vk </span><span class="cov0" title="0">{
                                if err := printer.PrintObj(resource, buf); err != nil </span><span class="cov0" title="0">{
                                        _, _ = fmt.Fprintf(buf, "failed to print object type %s: %v\n", t, err)
                                }</span>
                        }

                        <span class="cov0" title="0">buf.WriteString("\n")</span>
                }

        }

        <span class="cov0" title="0">return common.RespOK(c, buf.String())</span>
}

func runInstall(c *fiber.Ctx, r *releaseElement, justTemplate bool) (*release.Release, error) <span class="cov0" title="0">{
        vals, err := mergeValues(r.Values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client := action.NewInstall(actionConfig)
        client.ReleaseName = r.Name
        client.Namespace = r.Namespace
        client.Version = r.ChartVersion

        if justTemplate </span><span class="cov0" title="0">{
                client.DryRunOption = "true"
                client.DryRun = true
        }</span>

        <span class="cov0" title="0">aimChart := fmt.Sprintf("%s/%s", r.Repo, r.Chart)

        cp, err := client.ChartPathOptions.LocateChart(aimChart, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">validInstallableChart, err := isChartInstallable(chartRequested)
        if !validInstallableChart </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req := chartRequested.Metadata.Dependencies; req != nil </span><span class="cov0" title="0">{
                // If CheckDependencies returns an error, we have unfulfilled dependencies.
                // As of Helm 2.4.0, this is treated as a stopping condition:
                // https://github.com/helm/helm/issues/2209
                if err = action.CheckDependencies(chartRequested, req); err != nil </span><span class="cov0" title="0">{
                        if client.DependencyUpdate </span><span class="cov0" title="0">{
                                man := &amp;downloader.Manager{
                                        ChartPath:        cp,
                                        Keyring:          client.ChartPathOptions.Keyring,
                                        SkipUpdate:       false,
                                        Getters:          getter.All(settings),
                                        RepositoryConfig: settings.RepositoryConfig,
                                        RepositoryCache:  settings.RepositoryCache,
                                }
                                if err = man.Update(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }
        }

        <span class="cov0" title="0">rel, err := client.Run(chartRequested, vals)
        if err != nil </span><span class="cov0" title="0">{
                if rel != nil </span><span class="cov0" title="0">{
                        log.Errorf("installation failed:: namespace:%v, name:%v, status:%v, error:%v", rel.Namespace, rel.Name, rel.Info.Status.String(), err)
                        if rel.Info.Status == release.StatusFailed </span><span class="cov0" title="0">{
                                //uninstall release if installation failed (StatusFailed)
                                log.Infof("uninstall release:: namespace:%v, name:%v", rel.Namespace, rel.Name)
                                _ = runUninstall(actionConfig, rel.Name)
                        }</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">log.Infof("installed release status:: namespace:%v, name:%v, preview:%v, status:%v, desc:%v",
                rel.Namespace, rel.Name, justTemplate, rel.Info.Status, rel.Info.Description)

        return rel, nil</span>
}

func runUninstall(actionConfig *action.Configuration, name string) error <span class="cov0" title="0">{
        client := action.NewUninstall(actionConfig)
        _, err := client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("uninstallation failed :: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func isChartInstallable(ch *chart.Chart) (bool, error) <span class="cov0" title="0">{
        switch ch.Metadata.Type </span>{
        case "", "application":<span class="cov0" title="0">
                return true, nil</span>
        }

        <span class="cov0" title="0">return false, fmt.Errorf("charts are not installable")</span>
}

func constructReleaseElement(r *release.Release, showStatus bool) releaseElement <span class="cov0" title="0">{
        element := releaseElement{
                Name:         r.Name,
                Namespace:    r.Namespace,
                Revision:     strconv.Itoa(r.Version),
                Status:       r.Info.Status.String(),
                Chart:        r.Chart.Metadata.Name,
                ChartVersion: r.Chart.Metadata.Version,
                AppVersion:   procReplaceEmpty(r.Chart.Metadata.AppVersion),
                Icon:         r.Chart.Metadata.Icon,
                Resources:    make([]string, 0),
        }
        if showStatus </span><span class="cov0" title="0">{
                element.Notes = r.Info.Notes
        }</span>
        <span class="cov0" title="0">t := "-"
        if tspb := r.Info.LastDeployed; !tspb.IsZero() </span><span class="cov0" title="0">{
                t = tspb.Format(time.DateTime)
        }</span>
        <span class="cov0" title="0">element.Updated = t

        return element</span>
}

func constructReleaseInfoElement(r *release.Release, userDefined bool) (releaseElement, error) <span class="cov0" title="0">{
        values, err := mergeValuesUtil(r, userDefined)
        if err != nil </span><span class="cov0" title="0">{
                return releaseElement{}, err
        }</span>

        <span class="cov0" title="0">element := releaseElement{
                Name:         r.Name,
                Namespace:    r.Namespace,
                Revision:     strconv.Itoa(r.Version),
                Status:       r.Info.Status.String(),
                Chart:        r.Chart.Metadata.Name,
                ChartVersion: r.Chart.Metadata.Version,
                AppVersion:   procReplaceEmpty(r.Chart.Metadata.AppVersion),
                Home:         r.Chart.Metadata.Home,
                Icon:         r.Chart.Metadata.Icon,
                Notes:        r.Info.Notes,
                Values:       values,
                Resources:    GetResources(r.Manifest),
                Manifest:     r.Manifest,
        }

        t := "-"
        if tspb := r.Info.LastDeployed; !tspb.IsZero() </span><span class="cov0" title="0">{
                t = tspb.Format(time.DateTime)
        }</span>
        <span class="cov0" title="0">element.Updated = t

        return element, nil</span>
}

// MergeValues merges values from files specified via -f/--values and directly
// via --set-json, --set, --set-string, or --set-file, marshaling them to YAML
func mergeValues(values string) (map[string]interface{}, error) <span class="cov0" title="0">{
        byts := []byte(values)
        vals := map[string]interface{}{}

        if err := yaml.Unmarshal(byts, &amp;vals); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(common.FAILED_TO_PARSE_VALUES)
        }</span>
        <span class="cov0" title="0">return vals, nil</span>
}

func getReleaseHistory(rls []*release.Release) (history releaseHistory) <span class="cov0" title="0">{
        for i := len(rls) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                r := rls[i]
                c := formatChartname(r.Chart)
                s := r.Info.Status.String()
                v := r.Version
                d := r.Info.Description
                a := formatAppVersion(r.Chart)
                m := r.Manifest

                rInfo := releaseInfo{
                        Revision:    v,
                        Status:      s,
                        Chart:       c,
                        AppVersion:  procReplaceEmpty(a),
                        Description: d,
                        Manifest:    m,
                }
                if !r.Info.LastDeployed.IsZero() </span><span class="cov0" title="0">{
                        rInfo.Updated = r.Info.LastDeployed.Format(time.DateTime)

                }</span>
                <span class="cov0" title="0">history = append(history, rInfo)</span>
        }

        <span class="cov0" title="0">return history</span>
}

func formatChartname(c *chart.Chart) string <span class="cov0" title="0">{
        if c == nil || c.Metadata == nil </span><span class="cov0" title="0">{
                // This is an edge case that has happened in prod, though we don't
                // know how: https://github.com/helm/helm/issues/1347
                return "MISSING"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s-%s", c.Name(), c.Metadata.Version)</span>
}

func formatAppVersion(c *chart.Chart) string <span class="cov0" title="0">{
        if c == nil || c.Metadata == nil </span><span class="cov0" title="0">{
                // This is an edge case that has happened in prod, though we don't
                // know how: https://github.com/helm/helm/issues/1347
                return "MISSING"
        }</span>
        <span class="cov0" title="0">return c.AppVersion()</span>
}
func GetReleaseOld(c *fiber.Ctx) error <span class="cov0" title="0">{
        infos := []string{"hooks", "manifest", "notes", "values"}

        name := c.Params("release")
        info := c.Query("info")

        if info == "" </span><span class="cov0" title="0">{
                info = "values"
        }</span>

        <span class="cov0" title="0">infoMap := map[string]bool{}
        for _, i := range infos </span><span class="cov0" title="0">{
                infoMap[i] = true
        }</span>
        <span class="cov0" title="0">if _, ok := infoMap[info]; !ok </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf("bad info %s, release info only support hooks/manifest/notes/values", info))
        }</span>

        <span class="cov0" title="0">actionConfig, err := common.ActionConfigInit(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        // values
        <span class="cov0" title="0">if info == "values" </span><span class="cov0" title="0">{
                output := c.Query("output")
                // get values output format
                if output == "" </span><span class="cov0" title="0">{
                        output = "json"
                }</span>
                <span class="cov0" title="0">if output != "json" &amp;&amp; output != "yaml" </span><span class="cov0" title="0">{
                        return common.RespErr(c, fmt.Errorf("invalid format type %s, output only support json/yaml", output))
                }</span>

                <span class="cov0" title="0">client := action.NewGetValues(actionConfig)
                results, err := client.Run(name)
                if err != nil </span><span class="cov0" title="0">{
                        return common.RespErr(c, err)
                }</span>

                <span class="cov0" title="0">if output == "yaml" </span><span class="cov0" title="0">{
                        obj, err := yaml.Marshal(results)
                        if err != nil </span><span class="cov0" title="0">{
                                return common.RespErr(c, err)
                        }</span>
                        <span class="cov0" title="0">return common.RespOK(c, string(obj))</span>
                }
                <span class="cov0" title="0">return common.RespOK(c, results)</span>
        }

        <span class="cov0" title="0">client := action.NewGet(actionConfig)
        results, err := client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        // TODO: support all
        <span class="cov0" title="0">if info == "hooks" </span><span class="cov0" title="0">{
                if len(results.Hooks) &lt; 1 </span><span class="cov0" title="0">{
                        return common.RespOK(c, []*release.Hook{})
                }</span>
                <span class="cov0" title="0">return common.RespOK(c, results.Hooks)</span>

        } else<span class="cov0" title="0"> if info == "manifest" </span><span class="cov0" title="0">{
                return common.RespOK(c, results.Manifest)
        }</span> else<span class="cov0" title="0"> if info == "notes" </span><span class="cov0" title="0">{
                return common.RespOK(c, results.Info.Notes)

        }</span>

        <span class="cov0" title="0">return common.RespOK(c, nil)</span>
}

func getHistory(client *action.History, name string) (releaseHistory, error) <span class="cov0" title="0">{
        hist, err := client.Run(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">releaseutil.Reverse(hist, releaseutil.SortByRevision)

        var rels []*release.Release
        for i := len(hist) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                rels = append(rels, hist[i])
        }</span>

        <span class="cov0" title="0">if len(rels) == 0 </span><span class="cov0" title="0">{
                return releaseHistory{}, nil
        }</span>

        <span class="cov0" title="0">releaseHistory := getReleaseHistory(rels)

        return releaseHistory, nil</span>
}

func mergeValuesUtil(r *release.Release, f bool) (string, error) <span class="cov0" title="0">{
        allVals := r.Config

        if !f </span><span class="cov0" title="0">{
                merged, err := chartutil.MergeValues(r.Chart, r.Config)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to merge chart vals with user defined")
                }</span>
                <span class="cov0" title="0">allVals = merged</span>
        }

        <span class="cov0" title="0">if len(allVals) &gt; 0 </span><span class="cov0" title="0">{
                data, err := yaml.Marshal(allVals)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to serialize values into YAML")
                }</span>
                <span class="cov0" title="0">return string(data), nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "context"
        "fmt"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/log"
        "github.com/gofrs/flock"
        "github.com/pkg/errors"
        "go-api/common"
        "go-api/config"
        "helm.sh/helm/v3/cmd/helm/search"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/repo"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// Repositories that have been permanently deleted and no longer work
var deprecatedRepos = map[string]string{
        "//kubernetes-charts.storage.googleapis.com":           "https://charts.helm.sh/stable",
        "//kubernetes-charts-incubator.storage.googleapis.com": "https://charts.helm.sh/incubator",
}

type repositoryElement struct {
        Name string `json:"name"`
        URL  string `json:"url"`
}

type addRepositoryElement struct {
        Name     string `json:"name"`
        URL      string `json:"url"`
        Username string `json:"username"`
        Password string `json:"password"`
        CaBase64 string `json:"ca_base64"`
}

/*func addRepoVaildCheck(newRepo *addRepositoryElement) error {
        if newRepo.Name == "" || newRepo.URL == "" {
                return fmt.Errorf(common.REPO_NAME_URL_REQUIRED)
        }

        match, _ := regexp.MatchString(common.REPO_NAME_REGEXP_PATTERN, newRepo.Name)
        if !match {
                return fmt.Errorf(common.REPO_NAME_PATTERN_NOT_ALLOWED)
        }

        if strings.Contains(newRepo.Name, "/") {
                return fmt.Errorf(common.REPO_NAME_CONTAINS_SC)
        }
        // Block deprecated repos
        for oldURL, newURL := range deprecatedRepos {
                if strings.Contains(newRepo.URL, oldURL) {
                        return fmt.Errorf("repo %q is no longer available; try %q instead", newRepo.URL, newURL)
                }
        }

        if (newRepo.Username != "" &amp;&amp; newRepo.Password == "") || (newRepo.Username == "" &amp;&amp; newRepo.Password != "") {
                return errors.New(common.REPO_USERNAME_PASSWD_REQUIRED)
        }
        return nil
}
*/
// AddRepo
// @Summary Add Repository
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories [Post]
func AddRepo(c *fiber.Ctx) error <span class="cov8" title="1">{
        repoFile := settings.RepositoryConfig
        newRepo := new(addRepositoryElement)
        if err := c.BodyParser(newRepo); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>
        /*        if err := addRepoVaildCheck(newRepo); err != nil {
                        return common.RespErr(c, err)
                }
        */
        <span class="cov8" title="1">log.Infof("Add repo :: name: %s, url: %s", newRepo.Name, newRepo.URL)
        /*        if err := getRepoConnectionStatus(newRepo.URL); err != nil {
                        return common.RespErr(c, err)
                }
        */
        // Ensure the file directory exists as it is required for file locking
        err := os.MkdirAll(filepath.Dir(repoFile), os.ModePerm)
        if err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        // Acquire a file lock for process synchronization
        <span class="cov8" title="1">if err := syncRepoLock(repoFile); err != nil </span><span class="cov0" title="0">{

                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">f, err := repo.LoadFile(repoFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("AddRepo:: faild load file :: %v", err)
                return common.RespErr(c, fmt.Errorf(common.REPO_FAILED_LOADING_FILE))
        }</span>

        <span class="cov8" title="1">repoEntry := repo.Entry{
                Name:     newRepo.Name,
                URL:      newRepo.URL,
                Username: newRepo.Username,
                Password: newRepo.Password,
        }

        if f.Has(newRepo.Name) </span><span class="cov0" title="0">{
                existing := f.Get(newRepo.Name)
                if repoEntry != *existing </span><span class="cov0" title="0">{
                        return common.RespErr(c, errors.Errorf(common.REPO_NAME_ALREADY_EXISTS))
                }</span>
                // The add is idempotent so do nothing
                <span class="cov0" title="0">return common.RespErr(c, errors.Errorf(common.REPO_SAME_CONF_ALREADY_EXISTS))</span>
        }

        // save ca.crt
        <span class="cov8" title="1">caFilePath := ""
        if len(newRepo.CaBase64) &gt; 0 </span><span class="cov0" title="0">{
                caFile := fmt.Sprintf("%v_%v.crt", newRepo.Name, generatingId())
                caFilePath = filepath.Join(config.Env.HelmRepoCA, caFile)
                if err := os.MkdirAll(config.Env.HelmRepoCA, os.ModePerm); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return common.RespErr(c, err)
                }</span>
                /*        if err := saveRepoCaFile(caFilePath, newRepo.CaBase64); err != nil {
                        return common.RespErr(c, err)
                }*/
                <span class="cov0" title="0">repoEntry.CAFile = caFilePath</span>
        }

        <span class="cov8" title="1">r, err := repo.NewChartRepository(&amp;repoEntry, getter.All(settings))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("NewChartRepository ::  %s", err.Error())
                _ = RemoveFile(caFilePath)
                return common.RespErr(c, err)
        }</span>

        // set cache path
        <span class="cov8" title="1">if settings.RepositoryCache != "" </span><span class="cov8" title="1">{
                r.CachePath = settings.RepositoryCache
        }</span>

        <span class="cov8" title="1">if _, err := r.DownloadIndexFile(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("DownloadIndexFile ::  %s", err.Error())
                _ = RemoveFile(caFilePath)
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">f.Update(&amp;repoEntry)

        if err := f.WriteFile(repoFile, 0600); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Write Repofile ::  %s", err.Error())
                _ = RemoveFile(caFilePath)
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">return common.RespOK(c, nil)</span>
}

// ListRepos
// @Summary List Repository
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories [Get]
func ListRepos(c *fiber.Ctx) error <span class="cov8" title="1">{
        lse, err := ListSearchCheck(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">repositories, err := repo.LoadFile(settings.RepositoryConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ListRepos:: faild load file :: %v", err)
                return common.RespErr(c, fmt.Errorf(common.REPO_FAILED_LOADING_FILE))
        }</span>

        <span class="cov8" title="1">repos := make([]interface{}, 0, len(repositories.Repositories))
        for i := len(repositories.Repositories) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                re := repositories.Repositories[i]
                repos = append(repos, repositoryElement{Name: re.Name, URL: re.URL})
        }</span>

        <span class="cov8" title="1">itemCount, resultData := ResourceListProcessing(repos, lse)
        return common.ListRespOK(c, itemCount, resultData)</span>
}

// RemoveRepo
// @Summary Remove Repository
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories/:repositories [Delete]
func RemoveRepo(c *fiber.Ctx) error <span class="cov8" title="1">{
        repoName := c.Params("repositories")
        repoFile, err := repo.LoadFile(settings.RepositoryConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("RemoveRepo:: faild load file :: %v", err)
                return common.RespErr(c, fmt.Errorf(common.REPO_FAILED_LOADING_FILE))
        }</span>

        <span class="cov8" title="1">if !repoFile.Has(repoName) </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.REPO_NO_NAMED_FOUND))
        }</span>
        <span class="cov8" title="1">removeRepo := repoFile.Get(repoName)

        if !repoFile.Remove(repoName) </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">if err := repoFile.WriteFile(settings.RepositoryConfig, 0600); err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        /*        if err := removeRepoCache(settings.RepositoryCache, repoName); err != nil {
                        return common.RespErr(c, err)
                }
        */
        // delete repo ca.crt
        <span class="cov8" title="1">_ = RemoveFile(removeRepo.CAFile)

        return common.RespOK(c, nil)</span>
}

// UpdateRepo
// @Summary Update Repository
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories/:repositories [Put]
func UpdateRepo(c *fiber.Ctx) error <span class="cov8" title="1">{
        repoName := c.Params("repositories")
        repoFile, err := repo.LoadFile(settings.RepositoryConfig)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.REPO_FAILED_LOADING_FILE))
        }</span>
        <span class="cov8" title="1">if !repoFile.Has(repoName) </span><span class="cov0" title="0">{
                return common.RespErr(c, fmt.Errorf(common.REPO_NO_NAMED_FOUND))
        }</span>

        <span class="cov8" title="1">updateRepo := repoFile.Get(repoName)
        log.Infof("Update repo (name: %s, url: %s)", updateRepo.Name, updateRepo.URL)
        //err = updateChart(updateRepo)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to update repo.. %s", err.Error())
                return common.RespErr(c, fmt.Errorf(common.REPO_UNABLE_UPDATE))
        }</span>

        <span class="cov8" title="1">return common.RespOK(c, nil)</span>
}

// ListRepoCharts
// @Summary List Repository Charts
// @Tags Repository
// @Accept json
// @Produce json
// @Router /api/repositories/:repositories/charts [Get]
func ListRepoCharts(c *fiber.Ctx) error <span class="cov8" title="1">{
        lse, err := ListSearchCheck(c)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">repoName := c.Params("repositories")
        version := "&gt;0.0.0"
        index, err := buildSearchIndex(repoName)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">var res []*search.Result
        res = index.All()
        search.SortScore(res)
        data, err := applyConstraint(version, false, res)
        if err != nil </span><span class="cov0" title="0">{
                return common.RespErr(c, err)
        }</span>

        <span class="cov8" title="1">chartList := make([]interface{}, 0, len(data))
        for _, v := range data </span><span class="cov8" title="1">{
                chartList = append(chartList, repoChartElement{
                        Name:        strings.Replace(v.Chart.Name, repoName+"/", "", 1),
                        Version:     v.Chart.Version,
                        AppVersion:  v.Chart.AppVersion,
                        Description: v.Chart.Description,
                        Icon:        v.Chart.Icon,
                        RepoName:    repoName,
                        Deprecated:  v.Chart.Deprecated,
                })
        }</span>

        <span class="cov8" title="1">itemCount, resultData := ResourceListProcessing(chartList, lse)
        return common.ListRespOK(c, itemCount, resultData)</span>
}

func syncRepoLock(repoFile string) error <span class="cov8" title="1">{
        repoFileExt := filepath.Ext(repoFile)
        var lockPath string
        if len(repoFileExt) &gt; 0 &amp;&amp; len(repoFileExt) &lt; len(repoFile) </span><span class="cov8" title="1">{
                lockPath = strings.TrimSuffix(repoFile, repoFileExt) + ".lock"
        }</span> else<span class="cov0" title="0"> {
                lockPath = repoFile + ".lock"
        }</span>
        <span class="cov8" title="1">fileLock := flock.New(lockPath)
        lockCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        locked, err := fileLock.TryLockContext(lockCtx, time.Second)
        if err == nil &amp;&amp; locked </span><span class="cov8" title="1">{
                defer fileLock.Unlock()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
